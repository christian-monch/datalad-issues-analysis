{"url": "https://api.github.com/repos/datalad/datalad/issues/5798", "repository_url": "https://api.github.com/repos/datalad/datalad", "labels_url": "https://api.github.com/repos/datalad/datalad/issues/5798/labels{/name}", "comments_url": "https://api.github.com/repos/datalad/datalad/issues/5798/comments", "events_url": "https://api.github.com/repos/datalad/datalad/issues/5798/events", "html_url": "https://github.com/datalad/datalad/issues/5798", "id": 947075213, "node_id": "MDU6SXNzdWU5NDcwNzUyMTM=", "number": 5798, "title": "Future of datalad's API", "user": {"login": "bpoldrack", "id": 10498301, "node_id": "MDQ6VXNlcjEwNDk4MzAx", "avatar_url": "https://avatars.githubusercontent.com/u/10498301?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpoldrack", "html_url": "https://github.com/bpoldrack", "followers_url": "https://api.github.com/users/bpoldrack/followers", "following_url": "https://api.github.com/users/bpoldrack/following{/other_user}", "gists_url": "https://api.github.com/users/bpoldrack/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpoldrack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpoldrack/subscriptions", "organizations_url": "https://api.github.com/users/bpoldrack/orgs", "repos_url": "https://api.github.com/users/bpoldrack/repos", "events_url": "https://api.github.com/users/bpoldrack/events{/privacy}", "received_events_url": "https://api.github.com/users/bpoldrack/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2021-07-18T16:51:27Z", "updated_at": "2021-08-17T05:58:33Z", "closed_at": "2021-08-17T05:58:33Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "I want to try and discuss an approach on our (python-) interface and general architecture here. I think we kinda boxed ourselves into an unpleasant corner and I want to get out of it ASAP, since I believe things will get ever more dire otherwise. One major point to me is, that required design changes become ever more complicated as pretty much everything \"needs\" deprecation\r\ncycles. WRT design changes that means it's much more work and would require to maintain two different architectures at the same time. With several such changes that's simply not doable and maintainable and I don't see us getting much further that way. If I think of proper support for bare repos, several worktrees, sparse checkouts, different flavors of adjusted branches and so on, I don't see any of that happening w/o major changes in design (properly representing the actually different notions of \"a worktree\" and \"a repository\" for example, which right now is one and the same thing in datalad).\r\nBut we are currently not realistically able to do such changes and particularly the idea that the `*Repo` classes are part of the \"public\" interface is a major obstacle. However, this is *NOT* about the ultimate architecture, on the contrary it's about enabling us to constantly refactor most of the code base. There are several and more general aspects to this:\r\n\r\n\r\n1. What exactly is considered \"public\" interface is far from being well-defined to begin with. Obviously the CLI is, the `api`/`coreapi` modules are and the `Dataset` class is, too. However, there is no clear concept of what else is part of it and therefore needs proper deprecation cycles and what isn't (and we are free to change anytime).\r\nThe `*Repo` classes originally were not intended to be anything other than internal, but we do consider them \"public\" ATM, since the `Dataset.repo` property makes them available and it is \"public\". In my view that argument is flawed for two reasons. First, this confuses two different concepts of \"public\". The one relevant is \"what third party can/should access\", the other one being a C-like\r\nidea of public, protected, etc. as indicated by `_`, `__` prefixes in python. The latter concept actually is about class inheritance not about what kind of user has access. Furthermore it can't be (entirely) enforced in python and ultimately by that logic everything is public since one can import any class from equally \"public\" modules. This is no concept, but a quite arbitrary choice in my view.\r\nSince we can't really hide things, the important thing here is to have clear concept of what we consider to be the public interface and document it properly. Add a dedicated section to the docs, that declares what can be relied on, what can be expected to come with a deprecation if needed, and make clear that everything else is subject to sudden, unannounced change.\r\n\r\n    In my view, that interface should be in-line with the CLI. datalad is not a GitPython like module. Not every convenience we may have for dealing with repos needs to be part of that. For the command line user we basically say: These are the commands we provide. In addition you may want to use git+git-annex directly.\r\n    We should do the same in the python interface, I think. That means datalad's python interface is made of:\r\n        - `datalad.api` (proper deprecation)\r\n        - `datalad.coreapi` (particularly stable)\r\n        - `Dataset` (due to dynamic binding a mix of the above)\r\n        - `call_git/annex` functions to provide a python user with a way to call  git+git-annex directly and consistently in code that uses datalad. These should either be part of the `Dataset` class (easy) or we come up with an idea of how  to build a \"semi-command\", that is a function in `coreapi` that is also bound to `Dataset`. Just like a command but w/o command line exposure.\r\n        - Probably an additional abstraction lay below command implementations but above the `*Repos`. This would then supposed to be used by command implementations/extensions/`Dataset`-methods. See below for that. (proper deprecation cycle)\r\n        - That's it. Everything else is internal and can change anytime w/o warning.\r\n    This should go in a dedicated section in the docs and probably be linked to from the extension-template's README.\r\n\r\n\r\n2. We have pretty much nothing that deserves the term \"architecture\" from my POV. Command implementations go directly down to the `*Repo` classes. So, it's highest level straight down to almost lowest level. Even if there was no need for a design change - this is far from clean code principles. It requires to have the full complexity in mind while reading/writing the highest level things,\r\nit makes introducing layers in between hard, and it causes a good chunk of testing problems in my view. In an ideal world one would want to have several layers, that communicate via appropriate data structures and only \"one level\" up/down. \"Testable\" code would mean, that we can test the logic at any level w/o first creating the lowest level entities, and asserting things based on\r\nexecuting the highest level on it, but have actual *units* that can be fed with their input data structures and assert what they yield upwards. And that's what we largely do: Almost every test starts with creating/cloning a repository. The actual point of unit testing is to not do that over and over. You'd want to rely on that part being tested and everywhere else just start with a defined \"result record\" or whatever. I think that the lack of architecture is a big contributor to the mess that is our test battery (and it's runtime!). As mentioned in the beginning, I think that representing concepts like worktrees/checkouts, (adjusted) branches, etc. is essential to get to cleaner and better maintainable code. That requires a high-level abstraction layer that commands (and therefore extensions) use and absolute freedom underneath.\r\n\r\n3. Reiterating myself: There is no ultimate architecture, we need to be able constantly refactor the internal code base. I'm not about to propose the \"right\" architecture by any means. I simply want to get out of the situation where any meaningful change requires deprecation cycles during which several, different designs need to work at the same time and every change sparks a discussion about breakage. The largest part of the code base should be changeable at anytime and with no need to worry about \"breakage\". What is meant to be internal has to be treated as such.\r\n\r\nSo, what do we do?\r\n\r\nOne big shot radically breaking the status quo seems unlikely to work out on\r\nseveral fronts (including simply agreeing ;-) ).\r\n\r\nI think:\r\n- agree on a general \"interface definition\" (see 1.)\r\n- document it (incl. extensions-template repo)\r\n- introduce a \"non-public\" `Dataset` property `_vcs` (or similar) holding an\r\n  instance of a respective class `VCS`. This is supposed to become the\r\n  additional layer, I mentioned in 1. Command implementations and `Dataset`\r\n  methods are supposed to go through this. And it is the highest layer, that\r\n  henceforth promises deprecation cycles. Direct calls to something deeper down\r\n  are gonna break sooner or later w/o warning. In a first step this class will\r\n  be largely empty, of course. It gets the `repo` property from `Dataset` for\r\n  now and `Dataset.repo` refers to it.\r\n  It will doubtlessly take some time to figure out, what should go into this\r\n  class in what shape, but even if it would just proxy the `*Repo` methods for now,\r\n  it already serves the purpose of having that layer, that can - by changing the\r\n  implementation at that level - provide the shims to connect to any changed\r\n  design underneath, while everything else doesn't require such. Say, we need\r\n  `Dataset._vcs.is_annex` to replace the omnipresent `isinstance(Dataset.repo,\r\n  AnnexRepo)`. Such a method could right now simply do that `isinstance` test\r\n  and in that sense seem to be a pointless proxy. But if we were to decide that `AnnexRepo` is validated differently or is not\r\n  derived from `GitRepo` anymore or whatever else, we change `VCS.is_annex`. No\r\n  change to a command, extension or other third-party code. Conceptionally\r\n  (and by name) it should not represent any particular concept of a VCS (like a\r\n  repository, worktree or whatever) in order to not get into a situation where\r\n  future changes make it unclear and confusing. Its notion has to be quite\r\n  abstract.\r\n- Have directly in `Dataset` declared `call_git/annex` methods (that for now are\r\n  simply proxies of course via `._vcs`). If one wants to be fancy we might be able to create the\r\n  mentioned \"semi-command\" idea, but I think this is simple and straightforward.\r\n- With the above, we can then make sure, that all commands in core and our\r\n  extensions actually go through it.\r\n- Then it would be time to actually deprecate `Dataset.repo` with a proper\r\n  `DeprecationWarning`. Earlier isn't going to work, because even our own code\r\n  base would spam the user with those warnings. However, the documentation of\r\n  \"don't use this\" should come ASAP.\r\n- Actually shaping that `VCS` class will take time. Ideally one would want to\r\n  see high-level functionality that is used across commands and is somewhat\r\n  abstracted from \"what exact kind of repo am I on?\" (I think we thought about a\r\n  unified interface across repo flavors several times anyway). A possible route could be,\r\n  what @mih did in his PR about caching `*Repo` results via a command specific\r\n  `StaticRepo`. That kind of RF'ing could help to get a better understanding\r\n  what it is, that a command actually needs and wants to do/know when invoking\r\n  those methods (that is regardless of what I think of that particular way of\r\n  caching).\r\n\r\nI started drafting this in #5797.\r\n\r\n\r\nWDYT @datalad/developers? Agree in general or not? Suggestions for a (slightly)\r\ndifferent approach?\r\n", "closed_by": {"login": "bpoldrack", "id": 10498301, "node_id": "MDQ6VXNlcjEwNDk4MzAx", "avatar_url": "https://avatars.githubusercontent.com/u/10498301?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpoldrack", "html_url": "https://github.com/bpoldrack", "followers_url": "https://api.github.com/users/bpoldrack/followers", "following_url": "https://api.github.com/users/bpoldrack/following{/other_user}", "gists_url": "https://api.github.com/users/bpoldrack/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpoldrack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpoldrack/subscriptions", "organizations_url": "https://api.github.com/users/bpoldrack/orgs", "repos_url": "https://api.github.com/users/bpoldrack/repos", "events_url": "https://api.github.com/users/bpoldrack/events{/privacy}", "received_events_url": "https://api.github.com/users/bpoldrack/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/datalad/datalad/issues/5798/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/datalad/datalad/issues/5798/timeline", "performed_via_github_app": null}