{"url": "https://api.github.com/repos/datalad/datalad/issues/4698", "repository_url": "https://api.github.com/repos/datalad/datalad", "labels_url": "https://api.github.com/repos/datalad/datalad/issues/4698/labels{/name}", "comments_url": "https://api.github.com/repos/datalad/datalad/issues/4698/comments", "events_url": "https://api.github.com/repos/datalad/datalad/issues/4698/events", "html_url": "https://github.com/datalad/datalad/pull/4698", "id": 656062303, "node_id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDI2OTg4", "number": 4698, "title": "GitWitless-based call_git() and wipe out _git_custom_command()", "user": {"login": "mih", "id": 136479, "node_id": "MDQ6VXNlcjEzNjQ3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/136479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mih", "html_url": "https://github.com/mih", "followers_url": "https://api.github.com/users/mih/followers", "following_url": "https://api.github.com/users/mih/following{/other_user}", "gists_url": "https://api.github.com/users/mih/gists{/gist_id}", "starred_url": "https://api.github.com/users/mih/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mih/subscriptions", "organizations_url": "https://api.github.com/users/mih/orgs", "repos_url": "https://api.github.com/users/mih/repos", "events_url": "https://api.github.com/users/mih/events{/privacy}", "received_events_url": "https://api.github.com/users/mih/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1453907298, "node_id": "MDU6TGFiZWwxNDUzOTA3Mjk4", "url": "https://api.github.com/repos/datalad/datalad/labels/stale-PR-closed-without-merge", "name": "stale-PR-closed-without-merge", "color": "ffffff", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-07-13T18:46:58Z", "updated_at": "2021-09-24T10:18:55Z", "closed_at": "2020-08-28T12:46:58Z", "author_association": "MEMBER", "active_lock_reason": null, "pull_request": {"url": "https://api.github.com/repos/datalad/datalad/pulls/4698", "html_url": "https://github.com/datalad/datalad/pull/4698", "diff_url": "https://github.com/datalad/datalad/pull/4698.diff", "patch_url": "https://github.com/datalad/datalad/pull/4698.patch"}, "body": "This PR sits on top of #4689 and takes things a bit further:\r\n\r\n- Use `GitWitlessRunner` for `call_git*()` methods\r\n- Replace `_git_custom_command()` with `call_git*()` calls\r\n\r\nIn principle this is ready, but it shows some disturbing randomness in its behavior. The source for that is likely already present in 0.13, but now we are using this relatively new code much much more frequently for all kinds of tiny calls.\r\n\r\nAt present I have no idea where to start looking.\r\n\r\n<details>\r\n<summary>Diff to #4689 </summary>\r\n\r\n```diff\r\ndiff --git a/datalad/core/dataset/gitrepo.py b/datalad/core/dataset/gitrepo.py\r\nindex 8780ab713..e37cf42dd 100644\r\n--- a/datalad/core/dataset/gitrepo.py\r\n+++ b/datalad/core/dataset/gitrepo.py\r\n@@ -34,8 +34,9 @@ from datalad.support.exceptions import (\r\n     InvalidGitRepositoryError,\r\n )\r\n from datalad.cmd import (\r\n-    GitRunner,\r\n+    GitWitlessRunner,\r\n     run_gitcommand_on_file_list_chunks,\r\n+    StdOutErrCapture,\r\n )\r\n \r\n lgr = logging.getLogger('datalad.core.dataset.gitrepo')\r\n@@ -100,7 +101,7 @@ class GitRepo(RepoInterface, metaclass=PathBasedFlyweight):\r\n         # ['-c', 'receive.autogc=0', '-c', 'gc.auto=0']\r\n         self._GIT_COMMON_OPTIONS = []\r\n \r\n-        self._cmd_call_wrapper = GitRunner(cwd=path)\r\n+        self._git_runner = GitWitlessRunner(cwd=path)\r\n \r\n         # Set by fake_dates_enabled to cache config value across this instance.\r\n         self._fake_dates_enabled = None\r\n@@ -285,7 +286,7 @@ class GitRepo(RepoInterface, metaclass=PathBasedFlyweight):\r\n             yield dict(zip(fields, props))\r\n \r\n     def _call_git(self, args, files=None, expect_stderr=False, expect_fail=False,\r\n-                  honor_fake_dates=True, cwd=None, env=None, index_file=None):\r\n+                  honor_fake_dates=True, index_file=None):\r\n         \"\"\"Allows for calling arbitrary commands.\r\n \r\n         Internal helper to the call_git*() methods.\r\n@@ -317,30 +318,35 @@ class GitRepo(RepoInterface, metaclass=PathBasedFlyweight):\r\n         ------\r\n         CommandError if the call exits with a non-zero status.\r\n         \"\"\"\r\n+        runner = self._git_runner\r\n+        stderr_log_level = {True: 5, False: 11}[expect_stderr]\r\n+\r\n         cmd = ['git'] + self._GIT_COMMON_OPTIONS + args\r\n \r\n+        env = None\r\n         if honor_fake_dates and self.fake_dates_enabled:\r\n-            env = self.add_fake_dates(env)\r\n+            # start with the environment on record in the runner\r\n+            env = self.add_fake_dates(runner.env)\r\n \r\n         if index_file:\r\n-            env = (env if env is not None else environ).copy()\r\n+            # start with the environment on record in the runner\r\n+            env = (env if env is not None else runner.env).copy()\r\n             env['GIT_INDEX_FILE'] = index_file\r\n \r\n+        out = err = None\r\n         # TODO?: wouldn't splitting interfer with above GIT_INDEX_FILE\r\n         #  handling????\r\n         try:\r\n+            # keep track of the original, in case we override\r\n+            old_runner_env = runner.env\r\n+            if env is not None:\r\n+                runner.env = env\r\n             out, err = run_gitcommand_on_file_list_chunks(\r\n-                self._cmd_call_wrapper.run,\r\n+                self._git_runner.run,\r\n                 cmd,\r\n                 files,\r\n-                log_stderr=True,\r\n-                log_stdout=True,\r\n-                log_online=False,\r\n-                expect_stderr=expect_stderr,\r\n-                cwd=cwd,\r\n-                env=env,\r\n-                shell=None,\r\n-                expect_fail=expect_fail)\r\n+                protocol=StdOutErrCapture,\r\n+            )\r\n         except CommandError as e:\r\n             ignored = re.search(GitIgnoreError.pattern, e.stderr)\r\n             if ignored:\r\n@@ -348,8 +354,17 @@ class GitRepo(RepoInterface, metaclass=PathBasedFlyweight):\r\n                                      code=e.code, stdout=e.stdout,\r\n                                      stderr=e.stderr,\r\n                                      paths=ignored.groups()[0].splitlines())\r\n+            lgr.log(5 if expect_fail else 11, e)\r\n             raise\r\n-\r\n+        finally:\r\n+            if env is not None:\r\n+                # put back original env\r\n+                runner.env = old_runner_env\r\n+\r\n+        if err:\r\n+            for line in err.splitlines():\r\n+                lgr.log(stderr_log_level,\r\n+                        \"stderr| \" + line.rstrip('\\n'))\r\n         return out, err\r\n \r\n     # Convenience wrappers for one-off git calls that don't require further\r\n@@ -490,14 +505,14 @@ class GitRepo(RepoInterface, metaclass=PathBasedFlyweight):\r\n             return env\r\n         # prevent infinite recursion, should this function be called again\r\n         # inside the next call.\r\n-        environ['DATALAD_FAKE_DATE'] = '1'\r\n+        self._git_runner.env['DATALAD_FAKE_DATE'] = '1'\r\n         last_date = list(self.for_each_ref_(\r\n             fields='committerdate:raw',\r\n             count=1,\r\n             pattern='refs/heads',\r\n             sort=\"-committerdate\",\r\n         ))\r\n-        del environ['DATALAD_FAKE_DATE']\r\n+        del self._git_runner.env['DATALAD_FAKE_DATE']\r\n \r\n         if last_date:\r\n             # Drop the \"contextual\" timezone, leaving the unix timestamp.  We\r\ndiff --git a/datalad/support/annexrepo.py b/datalad/support/annexrepo.py\r\nindex 77de85dd6..890b56621 100644\r\n--- a/datalad/support/annexrepo.py\r\n+++ b/datalad/support/annexrepo.py\r\n@@ -693,25 +693,6 @@ class AnnexRepo(CoreAnnexRepo, GitRepo):\r\n             # might be an annex in direct mode\r\n             if git_options is None:\r\n                 git_options = []\r\n-            # TODO: Apparently doesn't work with git 2.11.0\r\n-            # Note: Since we are in a classmethod, GitRepo.get_toppath uses\r\n-            # Runner directly instead of _git_custom_command, which is why the\r\n-            # common mechanics for direct mode are not applied.\r\n-            # This is why there is no solution for git 2.11 yet\r\n-\r\n-            # Note 2: Actually, the above issue is irrelevant. The git\r\n-            # executable has no repository it is bound to, since it's the\r\n-            # purpose of the call to find this repository. Therefore\r\n-            # core.bare=False has no effect at all.\r\n-\r\n-            # Disabled. See notes.\r\n-            # git_options.extend(['-c', 'core.bare=False'])\r\n-            # toppath = GitRepo.get_toppath(path=path, follow_up=follow_up,\r\n-            #                               git_options=git_options)\r\n-\r\n-            # basically a copy of code in GitRepo.get_toppath\r\n-            # except it uses 'git rev-parse --git-dir' as a workaround for\r\n-            # direct mode:\r\n \r\n             from os.path import dirname\r\n             from os import pardir\r\n@@ -904,10 +885,27 @@ class AnnexRepo(CoreAnnexRepo, GitRepo):\r\n           working with a sameas remote, the presence of either \"sameas-name\" or\r\n           \"sameas-uuid\" is a reliable indicator.\r\n         \"\"\"\r\n+        argspec = re.compile(r'^([^=]*)=(.*)$')\r\n+        srs = {}\r\n         try:\r\n-            stdout, stderr = self._git_custom_command(\r\n-                None, ['git', 'cat-file', 'blob', 'git-annex:remote.log'],\r\n-                expect_fail=True)\r\n+            for line in self.call_git_items_(\r\n+                    ['cat-file', 'blob', 'git-annex:remote.log']):\r\n+                # be precise and split by spaces\r\n+                fields = line.split(' ')\r\n+                # special remote UUID\r\n+                sr_id = fields[0]\r\n+                # the rest are config args for enableremote\r\n+                sr_info = dict(argspec.match(arg).groups()[:2] for arg in fields[1:])\r\n+                if \"name\" not in sr_info:\r\n+                    name = sr_info.get(\"sameas-name\")\r\n+                    if name is None:\r\n+                        lgr.warning(\r\n+                            \"Encountered git-annex remote without a name or \"\r\n+                            \"sameas-name value: %s\",\r\n+                            sr_info)\r\n+                    else:\r\n+                        sr_info[\"name\"] = name\r\n+                srs[sr_id] = sr_info\r\n         except CommandError as e:\r\n             if 'Not a valid object name git-annex:remote.log' in e.stderr:\r\n                 # no special remotes configures\r\n@@ -915,25 +913,6 @@ class AnnexRepo(CoreAnnexRepo, GitRepo):\r\n             else:\r\n                 # some unforseen error\r\n                 raise e\r\n-        argspec = re.compile(r'^([^=]*)=(.*)$')\r\n-        srs = {}\r\n-        for line in stdout.splitlines():\r\n-            # be precise and split by spaces\r\n-            fields = line.split(' ')\r\n-            # special remote UUID\r\n-            sr_id = fields[0]\r\n-            # the rest are config args for enableremote\r\n-            sr_info = dict(argspec.match(arg).groups()[:2] for arg in fields[1:])\r\n-            if \"name\" not in sr_info:\r\n-                name = sr_info.get(\"sameas-name\")\r\n-                if name is None:\r\n-                    lgr.warning(\r\n-                        \"Encountered git-annex remote without a name or \"\r\n-                        \"sameas-name value: %s\",\r\n-                        sr_info)\r\n-                else:\r\n-                    sr_info[\"name\"] = name\r\n-            srs[sr_id] = sr_info\r\n         return srs\r\n \r\n     def _run_annex_command(self, annex_cmd,\r\ndiff --git a/datalad/support/gitrepo.py b/datalad/support/gitrepo.py\r\nindex 34691a0d0..806e13135 100644\r\n--- a/datalad/support/gitrepo.py\r\n+++ b/datalad/support/gitrepo.py\r\n@@ -893,9 +893,8 @@ class GitRepo(CoreGitRepo):\r\n         if kwargs:\r\n             git_opts.update(kwargs)\r\n \r\n-        if runner:\r\n-            # override the default GitRunner established by the base class\r\n-            self._cmd_call_wrapper = runner\r\n+        # TODO: remove any usage of this, and rely on call_git()\r\n+        self._cmd_call_wrapper = runner if runner else GitRunner(cwd=path)\r\n \r\n         if do_create:  # we figured it out earlier\r\n             self._create_empty_repo(path, create_sanity_checks, **git_opts)\r\n@@ -917,8 +916,8 @@ class GitRepo(CoreGitRepo):\r\n             # under a directory some files of which are already tracked by git\r\n             # use case: https://github.com/datalad/datalad/issues/3068\r\n             try:\r\n-                stdout, _ = self._git_custom_command(\r\n-                    None, ['git', 'ls-files'], cwd=path, expect_fail=True\r\n+                stdout = self.call_git(\r\n+                    ['-C', path, 'ls-files'], expect_fail=True\r\n                 )\r\n                 if stdout:\r\n                     raise PathKnownToRepositoryError(\r\n@@ -930,31 +929,23 @@ class GitRepo(CoreGitRepo):\r\n                 # assume that all is good -- we are not under any repo\r\n                 pass\r\n \r\n-        cmd = ['git', 'init']\r\n+        cmd = ['-C', path, 'init']\r\n         cmd.extend(kwargs.pop('_from_cmdline_', []))\r\n         cmd.extend(to_options(**kwargs))\r\n         lgr.debug(\r\n             \"Initialize empty Git repository at '%s'%s\",\r\n             path,\r\n-            ' %s' % cmd[2:] if cmd[2:] else '')\r\n+            ' %s' % cmd[3:] if cmd[3:] else '')\r\n \r\n         try:\r\n-            stdout, stderr = self._git_custom_command(\r\n-                None,\r\n+            stdout = self.call_git(\r\n                 cmd,\r\n-                cwd=path,\r\n-                log_stderr=True,\r\n-                log_stdout=True,\r\n-                log_online=False,\r\n-                expect_stderr=False,\r\n-                shell=False,\r\n                 # we don't want it to scream on stdout\r\n                 expect_fail=True)\r\n         except CommandError as exc:\r\n             lgr.error(exc_str(exc))\r\n             raise\r\n \r\n-\r\n     @classmethod\r\n     def clone(cls, url, path, *args, clone_options=None, **kwargs):\r\n         \"\"\"Clone url into path\r\n@@ -1229,13 +1220,13 @@ class GitRepo(CoreGitRepo):\r\n \r\n         try:\r\n             # without --verbose git 2.9.3  add does not return anything\r\n-            add_out = self._git_custom_command(\r\n-                files,\r\n+            add_out = self._call_git(\r\n                 # Set annex.largefiles to prevent storing files in\r\n                 # annex with a v6+ annex repo.\r\n-                ['git', '-c', 'annex.largefiles=nothing', 'add'] +\r\n+                ['-c', 'annex.largefiles=nothing', 'add'] +\r\n                 ensure_list(git_options) +\r\n-                to_options(update=update) + ['--verbose']\r\n+                to_options(update=update) + ['--verbose'],\r\n+                files=files,\r\n             )\r\n             # get all the entries\r\n             for o in self._process_git_get_output(*add_out):\r\n@@ -1300,11 +1291,13 @@ class GitRepo(CoreGitRepo):\r\n         \"\"\"\r\n         if recursive:\r\n             kwargs['r'] = True\r\n-        stdout, stderr = self._git_custom_command(\r\n-            files, ['git', 'rm'] + to_options(**kwargs))\r\n \r\n         # output per removed file is expected to be \"rm 'PATH'\":\r\n-        return [line.strip()[4:-1] for line in stdout.splitlines()]\r\n+        return [\r\n+            line.strip()[4:-1]\r\n+            for line in self.call_git_items_(\r\n+                ['rm'] + to_options(**kwargs), files=files)\r\n+        ]\r\n \r\n     def precommit(self):\r\n         \"\"\"Perform pre-commit maintenance tasks\r\n@@ -1450,14 +1443,14 @@ class GitRepo(CoreGitRepo):\r\n         -------\r\n         str or, if there are not commits yet, None.\r\n         \"\"\"\r\n-        cmd = ['git', 'show', '-z', '--no-patch', '--format=' + fmt]\r\n+        cmd = ['show', '-z', '--no-patch', '--format=' + fmt]\r\n         if commitish is not None:\r\n             cmd.append(commitish + \"^{commit}\")\r\n         # make sure Git takes our argument as a revision\r\n         cmd.append('--')\r\n         try:\r\n-            stdout, stderr = self._git_custom_command(\r\n-                '', cmd, expect_stderr=True, expect_fail=True)\r\n+            stdout = self.call_git(\r\n+                cmd, expect_stderr=True, expect_fail=True)\r\n         except CommandError as e:\r\n             if 'bad revision' in e.stderr:\r\n                 raise ValueError(\"Unknown commit identifier: %s\" % commitish)\r\n@@ -1739,78 +1732,6 @@ class GitRepo(CoreGitRepo):\r\n                 paths=None, ref=branch, untracked='no', eval_file_type=False)\r\n             ]\r\n \r\n-    @normalize_paths(match_return_type=False)\r\n-    def _git_custom_command(self, files, cmd_str,\r\n-                            log_stdout=True, log_stderr=True, log_online=False,\r\n-                            expect_stderr=True, cwd=None, env=None,\r\n-                            shell=None, expect_fail=False,\r\n-                            check_fake_dates=False,\r\n-                            index_file=None,\r\n-                            updates_tree=False):\r\n-        \"\"\"Allows for calling arbitrary commands.\r\n-\r\n-        The method should be avoided and the call_git*() should be used instead.\r\n-\r\n-        Parameters\r\n-        ----------\r\n-        files: list of files\r\n-        cmd_str: str or list\r\n-          arbitrary command str. `files` is appended to that string.\r\n-        updates_tree: bool\r\n-          whether or not command updates the working tree. If True, triggers\r\n-          necessary reevaluations like self.config.reload()\r\n-\r\n-        Returns\r\n-        -------\r\n-        stdout, stderr\r\n-        \"\"\"\r\n-\r\n-        # ensure cmd_str becomes a well-formed list:\r\n-        if isinstance(cmd_str, str):\r\n-            cmd = split_cmdline(cmd_str)\r\n-        else:\r\n-            cmd = cmd_str[:]  # we will modify in-place\r\n-\r\n-        assert(cmd[0] == 'git')\r\n-        cmd = cmd[:1] + self._GIT_COMMON_OPTIONS + cmd[1:]\r\n-\r\n-        if check_fake_dates and self.fake_dates_enabled:\r\n-            env = self.add_fake_dates(env)\r\n-\r\n-        if index_file:\r\n-            env = (env if env is not None else os.environ).copy()\r\n-            env['GIT_INDEX_FILE'] = index_file\r\n-\r\n-        # TODO?: wouldn't splitting interfer with above GIT_INDEX_FILE\r\n-        #  handling????\r\n-        try:\r\n-            out, err = run_gitcommand_on_file_list_chunks(\r\n-                self._cmd_call_wrapper.run,\r\n-                cmd,\r\n-                files,\r\n-                log_stderr=log_stderr,\r\n-                log_stdout=log_stdout,\r\n-                log_online=log_online,\r\n-                expect_stderr=expect_stderr,\r\n-                cwd=cwd,\r\n-                env=env,\r\n-                shell=shell,\r\n-                expect_fail=expect_fail)\r\n-        except CommandError as e:\r\n-            ignored = re.search(GitIgnoreError.pattern, e.stderr)\r\n-            if ignored:\r\n-                raise GitIgnoreError(cmd=e.cmd, msg=e.stderr,\r\n-                                     code=e.code, stdout=e.stdout,\r\n-                                     stderr=e.stderr,\r\n-                                     paths=ignored.groups()[0].splitlines())\r\n-            raise\r\n-\r\n-        if updates_tree:\r\n-            lgr.debug(\"Reloading config due to supposed working tree update\")\r\n-            self.config.reload()\r\n-\r\n-        return out, err\r\n-\r\n     def add_remote(self, name, url, options=None):\r\n         \"\"\"Register remote pointing to a url\r\n         \"\"\"\r\n@@ -2218,9 +2139,8 @@ class GitRepo(CoreGitRepo):\r\n         if msg:\r\n             options = options + [\"-m\", msg]\r\n         options += ['--allow-unrelated-histories']\r\n-        self._git_custom_command(\r\n-            '', ['git', 'merge'] + options + [name],\r\n-            check_fake_dates=True,\r\n+        self.call_git(\r\n+            ['merge'] + options + [name],\r\n             **kwargs\r\n         )\r\n \r\n@@ -2756,15 +2676,14 @@ class GitRepo(CoreGitRepo):\r\n           for set and unset attributes, or are the literal attribute value.\r\n         \"\"\"\r\n         path = ensure_list(path)\r\n-        cmd = [\"git\", \"check-attr\", \"-z\", \"--all\"]\r\n+        cmd = [\"check-attr\", \"-z\", \"--all\"]\r\n         if index_only:\r\n             cmd.append('--cached')\r\n-        stdout, stderr = self._git_custom_command(path, cmd)\r\n         # make sure we have one entry for each query path to\r\n         # simplify work with the result\r\n-        attributes = {_normalize_path(self.path, p): {} for p in path}\r\n+        attributes = {p: {} for p in path}\r\n         attr = []\r\n-        for item in stdout.split('\\0'):\r\n+        for item in self.call_git_items_(cmd, files=path, sep='\\0'):\r\n             attr.append(item)\r\n             if len(attr) < 3:\r\n                 continue\r\n@@ -2775,7 +2694,13 @@ class GitRepo(CoreGitRepo):\r\n                 True if value == 'set' else False if value == 'unset' else value\r\n             # done, reset item\r\n             attr = []\r\n-        return attributes\r\n+        # normalize to relative path keys, to maintain the promise made in the docs\r\n+        # TODO switch to absolute paths like in the rest of the newer code\r\n+        return {\r\n+            str(Path(k).relative_to(self.pathobj)) if isabs(k) else k:\r\n+            v\r\n+            for k, v in attributes.items()\r\n+        }\r\n \r\n     def set_gitattributes(self, attrs, attrfile='.gitattributes', mode='a'):\r\n         \"\"\"Set gitattributes\r\n@@ -2915,7 +2840,7 @@ class GitRepo(CoreGitRepo):\r\n             # --exclude-standard will make sure to honor and standard way\r\n             # git can be instructed to ignore content, and will prevent\r\n             # crap from contaminating untracked file reports\r\n-            cmd = ['git', 'ls-files',\r\n+            cmd = ['ls-files',\r\n                    '--stage', '-z', '-d', '-m', '--exclude-standard']\r\n             # untracked report mode, using labels from `git diff` option style\r\n             if untracked == 'all':\r\n@@ -2938,22 +2863,15 @@ class GitRepo(CoreGitRepo):\r\n                               for s in self.get_submodules_()]\r\n                 path_strs = get_parent_paths(path_strs, submodules)\r\n         else:\r\n-            cmd = ['git', 'ls-tree', ref, '-z', '-r', '--full-tree', '-l']\r\n+            cmd = ['ls-tree', ref, '-z', '-r', '--full-tree', '-l']\r\n             props_re = re.compile(\r\n                 r'(?P<type>[0-9]+) ([a-z]*) (?P<sha>[^ ]*) [\\s]*(?P<size>[0-9-]+)\\t(?P<fname>.*)$')\r\n \r\n         lgr.debug('Query repo: %s', cmd)\r\n         try:\r\n-            stdout, stderr = self._git_custom_command(\r\n-                path_strs,\r\n+            stdout = self.call_git(\r\n                 cmd,\r\n-                log_stderr=True,\r\n-                log_stdout=True,\r\n-                # not sure why exactly, but log_online has to be false!\r\n-                log_online=False,\r\n-                expect_stderr=False,\r\n-                shell=False,\r\n-                # we don't want it to scream on stdout\r\n+                files=path_strs,\r\n                 expect_fail=True)\r\n         except CommandError as exc:\r\n             if \"fatal: Not a valid object name\" in exc.stderr:\r\n@@ -3200,10 +3118,11 @@ class GitRepo(CoreGitRepo):\r\n             else:\r\n                 modified = set(\r\n                     self.pathobj.joinpath(ut.PurePosixPath(p))\r\n-                    for p in self._git_custom_command(\r\n+                    for p in self.call_git_items_(\r\n                         # low-level code cannot handle pathobjs\r\n-                        [str(p) for p in paths] if paths else None,\r\n-                        ['git', 'ls-files', '-z', '-m'])[0].split('\\0')\r\n+                        ['ls-files', '-z', '-m'],\r\n+                        files=[str(p) for p in paths] if paths else None,\r\n+                        sep='\\0')\r\n                     if p)\r\n                 _cache[key] = modified\r\n         else:\r\n@@ -3399,19 +3318,12 @@ class GitRepo(CoreGitRepo):\r\n         in the worktree.\r\n         \"\"\"\r\n         try:\r\n-            stdout, stderr = self._git_custom_command(\r\n-                None,\r\n+            return list(self.call_git_items_(\r\n                 ['git', 'diff', '--name-only', '--staged'],\r\n-                cwd=self.path,\r\n-                log_stderr=True,\r\n-                log_stdout=True,\r\n-                log_online=False,\r\n-                expect_stderr=False,\r\n-                expect_fail=True)\r\n+                expect_stderr=True))\r\n         except CommandError as e:\r\n             lgr.debug(exc_str(e))\r\n-            stdout = ''\r\n-        return [f for f in stdout.split('\\n') if f]\r\n+            return []\r\n \r\n     def _save_post(self, message, status, partial_commit):\r\n         # helper to commit changes reported in status\r\n@@ -3638,12 +3550,12 @@ class GitRepo(CoreGitRepo):\r\n         from datalad.interface.results import get_status_dict\r\n         try:\r\n             # without --verbose git 2.9.3  add does not return anything\r\n-            add_out = self._git_custom_command(\r\n-                list(files.keys()),\r\n+            add_out = self._call_git(\r\n                 # Set annex.largefiles to prevent storing files in\r\n                 # annex with a v6+ annex repo.\r\n-                ['git', '-c', 'annex.largefiles=nothing', 'add'] +\r\n-                ensure_list(git_opts) + ['--verbose']\r\n+                ['-c', 'annex.largefiles=nothing', 'add'] + ensure_list(\r\n+                    git_opts) + ['--verbose'],\r\n+                files=list(files.keys()),\r\n             )\r\n             # get all the entries\r\n             for r in self._process_git_get_output(*add_out):\r\ndiff --git a/datalad/support/tests/test_gitrepo.py b/datalad/support/tests/test_gitrepo.py\r\nindex e2d9f5aa4..d7c5dbff5 100644\r\n--- a/datalad/support/tests/test_gitrepo.py\r\n+++ b/datalad/support/tests/test_gitrepo.py\r\n@@ -1416,34 +1416,6 @@ def test_fake_dates(path):\r\n     eq_(seconds_initial + 3, gr.get_commit_date())\r\n \r\n \r\n-@with_tree(tree={\"foo\": \"foo content\"})\r\n-def test_custom_runner_protocol(path):\r\n-    # Check that a runner with a non-default protocol gets wired up correctly.\r\n-    prot = ExecutionTimeProtocol()\r\n-    gr = GitRepo(path, runner=Runner(cwd=path, protocol=prot), create=True)\r\n-\r\n-    ok_(len(prot) > 0)\r\n-    ok_(prot[0]['duration'] >= 0)\r\n-\r\n-    def check(prev_len, prot, command):\r\n-        # Check that the list grew and has the expected command without\r\n-        # assuming that it gained _only_ a one command.\r\n-        ok_(len(prot) > prev_len)\r\n-        assert_in(command,\r\n-                  sum([p[\"command\"] for p in prot[prev_len:]], []))\r\n-\r\n-    prev_len = len(prot)\r\n-    gr.add(\"foo\")\r\n-    check(prev_len, prot, \"add\")\r\n-\r\n-    # commit no longer uses a Runner with protocol capabilities\r\n-    #prev_len = len(prot)\r\n-    #gr.commit(\"commit foo\")\r\n-    #check(prev_len, prot, \"commit\")\r\n-\r\n-    ok_(all(p['duration'] >= 0 for p in prot))\r\n-\r\n-\r\n @with_tempfile(mkdir=True)\r\n def test_duecredit(path):\r\n     # Just to check that no obvious side-effects\r\n@@ -1547,7 +1519,7 @@ def test_gitrepo_call_git_methods(path):\r\n             with assert_raises(CommandError):\r\n                 gr.call_git([\"mv\"], files=[\"notthere\", \"dest\"],\r\n                             expect_fail=expect_fail)\r\n-            check(\"notthere\", cml.out)\r\n+            check(\"fatal: bad source\", cml.out)\r\n \r\n     eq_(list(gr.call_git_items_([\"ls-files\"])),\r\n         [\"bar\", \"foo.txt\"])\r\n@@ -1565,7 +1537,7 @@ def test_gitrepo_call_git_methods(path):\r\n     ok_(gr.call_git_success([\"rev-parse\", \"HEAD^{commit}\"]))\r\n     with swallow_logs(new_level=logging.DEBUG) as cml:\r\n         assert_false(gr.call_git_success([\"rev-parse\", \"HEAD^{blob}\"]))\r\n-        assert_not_in(\"blob\", cml.out)\r\n+        assert_not_in(\"fatal: ambiguous argument\", cml.out)\r\n \r\n \r\n @skip_if_no_network\r\ndiff --git a/datalad/tests/utils_testrepos.py b/datalad/tests/utils_testrepos.py\r\nindex aca1fac4a..6658931a1 100644\r\n--- a/datalad/tests/utils_testrepos.py\r\n+++ b/datalad/tests/utils_testrepos.py\r\n@@ -158,14 +158,14 @@ class SubmoduleDataset(BasicAnnexTestRepo):\r\n         # add submodules\r\n         annex = BasicAnnexTestRepo()\r\n         annex.create()\r\n-        kw = dict(cwd=self.path, expect_stderr=True)\r\n-        self.repo._git_custom_command(\r\n-            '', ['git', 'submodule', 'add', annex.url, 'subm 1'], **kw)\r\n-        self.repo._git_custom_command(\r\n-            '', ['git', 'submodule', 'add', annex.url, '2'], **kw)\r\n+        kw = dict(expect_stderr=True)\r\n+        self.repo.call_git(\r\n+            ['submodule', 'add', annex.url, 'subm 1'], **kw)\r\n+        self.repo.call_git(\r\n+            ['submodule', 'add', annex.url, '2'], **kw)\r\n         self.repo.commit('Added subm 1 and 2.')\r\n-        self.repo._git_custom_command(\r\n-            '', ['git', 'submodule', 'update', '--init', '--recursive'], **kw)\r\n+        self.repo.call_git(\r\n+            ['submodule', 'update', '--init', '--recursive'], **kw)\r\n         # init annex in subdatasets\r\n         for s in ('subm 1', '2'):\r\n             AnnexRepo(opj(self.path, s), init=True)\r\n@@ -178,17 +178,18 @@ class NestedDataset(BasicAnnexTestRepo):\r\n         ds = SubmoduleDataset()\r\n         ds.create()\r\n         kw = dict(expect_stderr=True)\r\n-        self.repo._git_custom_command(\r\n-            '', ['git', 'submodule', 'add', ds.url, 'sub dataset1'],\r\n-            cwd=self.path, **kw)\r\n-        self.repo._git_custom_command(\r\n-            '', ['git', 'submodule', 'add', ds.url, 'sub sub dataset1'],\r\n-            cwd=opj(self.path, 'sub dataset1'), **kw)\r\n+        self.repo.call_git(\r\n+            ['submodule', 'add', ds.url, 'sub dataset1'],\r\n+            **kw)\r\n+        self.repo.call_git(\r\n+            ['-C', opj(self.path, 'sub dataset1'),\r\n+             'submodule', 'add', ds.url, 'sub sub dataset1'],\r\n+            **kw)\r\n         GitRepo(opj(self.path, 'sub dataset1')).commit('Added sub dataset.')\r\n         self.repo.commit('Added subdatasets.', options=[\"-a\"])\r\n-        self.repo._git_custom_command(\r\n-            '', ['git', 'submodule', 'update', '--init', '--recursive'],\r\n-            cwd=self.path, **kw)\r\n+        self.repo.call_git(\r\n+            ['submodule', 'update', '--init', '--recursive'],\r\n+            **kw)\r\n         # init all annexes\r\n         for s in ('', 'sub dataset1', opj('sub dataset1', 'sub sub dataset1')):\r\n             AnnexRepo(opj(self.path, s), init=True)\r\n```\r\n</details>", "closed_by": {"login": "mih", "id": 136479, "node_id": "MDQ6VXNlcjEzNjQ3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/136479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mih", "html_url": "https://github.com/mih", "followers_url": "https://api.github.com/users/mih/followers", "following_url": "https://api.github.com/users/mih/following{/other_user}", "gists_url": "https://api.github.com/users/mih/gists{/gist_id}", "starred_url": "https://api.github.com/users/mih/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mih/subscriptions", "organizations_url": "https://api.github.com/users/mih/orgs", "repos_url": "https://api.github.com/users/mih/repos", "events_url": "https://api.github.com/users/mih/events{/privacy}", "received_events_url": "https://api.github.com/users/mih/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/datalad/datalad/issues/4698/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/datalad/datalad/issues/4698/timeline", "performed_via_github_app": null}