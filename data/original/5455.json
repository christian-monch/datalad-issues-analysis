{"url": "https://api.github.com/repos/datalad/datalad/issues/5455", "repository_url": "https://api.github.com/repos/datalad/datalad", "labels_url": "https://api.github.com/repos/datalad/datalad/issues/5455/labels{/name}", "comments_url": "https://api.github.com/repos/datalad/datalad/issues/5455/comments", "events_url": "https://api.github.com/repos/datalad/datalad/issues/5455/events", "html_url": "https://github.com/datalad/datalad/issues/5455", "id": 820907501, "node_id": "MDU6SXNzdWU4MjA5MDc1MDE=", "number": 5455, "title": "save --amend --recursive", "user": {"login": "bpoldrack", "id": 10498301, "node_id": "MDQ6VXNlcjEwNDk4MzAx", "avatar_url": "https://avatars.githubusercontent.com/u/10498301?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpoldrack", "html_url": "https://github.com/bpoldrack", "followers_url": "https://api.github.com/users/bpoldrack/followers", "following_url": "https://api.github.com/users/bpoldrack/following{/other_user}", "gists_url": "https://api.github.com/users/bpoldrack/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpoldrack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpoldrack/subscriptions", "organizations_url": "https://api.github.com/users/bpoldrack/orgs", "repos_url": "https://api.github.com/users/bpoldrack/repos", "events_url": "https://api.github.com/users/bpoldrack/events{/privacy}", "received_events_url": "https://api.github.com/users/bpoldrack/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 2767271225, "node_id": "MDU6TGFiZWwyNzY3MjcxMjI1", "url": "https://api.github.com/repos/datalad/datalad/labels/cmd-save", "name": "cmd-save", "color": "FEF2C0", "default": false, "description": ""}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2021-03-03T09:09:44Z", "updated_at": "2021-03-03T15:27:50Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "In PR #5430 `--amend` was made incompatible with `--recursive`, since it's not too easy and may need more consideration of what behavior would sensible and what corner cases there are. Putting state of things here instead to eventually pick up again.\r\n\r\nMy current take on what to aim for:\r\n`save --amend --recursive` should only result in amended commits in subdatasets, when they were modified in the commit we are amending. If there are to be saved modifications in other subdatasets, they should get a new commit instead and then the amendment should happen only upstairs. Basically: Modifications recorded in the resulting commit (-hierarchy) should be the same as if the last things (recursively) saved, were still unsaved and we ran a `save --recursive`.\r\n\r\nPiece of code I was starting with in `save` right after `paths_by_ds` is build:\r\n\r\n```\r\n        # TODO: if amend, inspect prev. commit for what subdatasets were\r\n        #       modified in it. Recursive amend should lead to amended commits\r\n        #       in subdatasets only, if they were modified inn the prev. commit.\r\n        #       Otherwise we want a separate commit, but amend that change\r\n        #       upwards.\r\n        #       Inspection record combined with path_by_ds should then lead to a\r\n        #       structure to be passed into save_, that would tell when to amend\r\n        #       and when not to.\r\n        #       Meaning the anticipation below of which subdatasets to commit\r\n        #       needs to change and be based on this inspection.\r\n        prev_modified_ds = list()\r\n        if amend and recursive:\r\n            from datalad.consts import PRE_INIT_COMMIT_SHA\r\n\r\n            if hasattr(ds.repo, 'get_corresponding_branch'):\r\n                branch = ds.repo.get_corresponding_branch() or \\\r\n                         ds.repo.get_active_branch()\r\n            else:\r\n                branch = ds.repo.get_active_branch()\r\n\r\n            # TODO: logic for magic hash should prob. be incorporated w/ diff\r\n            try:\r\n                parent = ds.repo.get_hexsha(f\"{branch}~1\")\r\n            except ValueError:\r\n                # If branch commit doesn't have a parent, we use magic hash\r\n                # with diff:\r\n                parent = PRE_INIT_COMMIT_SHA\r\n\r\n            for d in ds.diff(fr=parent, to=branch,\r\n                             recursive=True,\r\n                             recursion_limit=recursion_limit,\r\n                             result_renderer='disabled'):\r\n                if d['action'] != 'diff':\r\n                    yield d\r\n                    continue\r\n                if d['type'] == 'dataset' and d['state'] != 'clean':\r\n                    prev_modified_ds.append(d['path'])\r\n\r\n            # TODO: Is the following still true?\r\n\r\n            if message:\r\n                # We need to anticipate empty amend commits in subdatasets that\r\n                # currently appear to be clean. Change state of any subdataset to\r\n                # modified in order for it to be committed upwards after amending.\r\n                # Note, that at least a message is required in order to actually commit\r\n                # in a subdataset that otherwise is clean.\r\n                for d in paths_by_ds:\r\n                    for p in paths_by_ds[d]:\r\n                        if paths_by_ds[d][p]['type'] == 'dataset' and \\\r\n                                paths_by_ds[d][p]['state'] == 'clean' and \\\r\n                                d in prev_modified_ds:\r\n                            paths_by_ds[d][p]['state'] = 'modified'\r\n```\r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/datalad/datalad/issues/5455/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/datalad/datalad/issues/5455/timeline", "performed_via_github_app": null}